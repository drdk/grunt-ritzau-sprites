// Generated by CoffeeScript 1.6.3
var SpriteGenerator, XMLHttpRequest, done, evaluation, fs, http, parseXml, phantom,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

evaluation = function(options) {
  var canvas, channel, channels, css, cssTemplate, ctx, filenamePrefix, height, image, largestImageWithIdent, logoPath, moo, offset, result, width, _i, _j, _len, _len1;
  cssTemplate = options.cssTemplate;
  channels = options.channels;
  logoPath = options.logoPath;
  filenamePrefix = options.filenamePrefix;
  moo = [];
  String.prototype.replaceObject = function(obj) {
    var key, re, result;
    result = this;
    for (key in obj) {
      re = new RegExp("{" + key + "}", "g");
      result = result.replace(re, obj[key]);
    }
    return result;
  };
  largestImageWithIdent = function(ident) {
    var image, images, maxWidth, result, _i, _len;
    maxWidth = 0;
    images = document.querySelectorAll("img");
    result = null;
    for (_i = 0, _len = images.length; _i < _len; _i++) {
      image = images[_i];
      if (image.getAttribute("data-ident") !== ident) {
        continue;
      }
      if (image.width > maxWidth) {
        maxWidth = image.width;
        result = image;
      }
    }
    return result;
  };
  width = 0;
  height = 0;
  css = "";
  for (_i = 0, _len = channels.length; _i < _len; _i++) {
    channel = channels[_i];
    image = largestImageWithIdent(channel.ident);
    if (image) {
      if (!(image.height >= 30)) {
        moo.push(channel.ident);
      }
      channel.spriteImage = image;
      if (!(width >= image.width)) {
        width = image.width;
      }
      height += image.height;
    }
  }
  canvas = document.getElementById("sprite");
  ctx = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  offset = 0;
  for (_j = 0, _len1 = channels.length; _j < _len1; _j++) {
    channel = channels[_j];
    if (!channel.spriteImage) {
      continue;
    }
    ctx.drawImage(channel.spriteImage, 0, offset);
    offset += channel.spriteImage.height;
    css += "\n\n" + cssTemplate.replaceObject({
      name: "" + filenamePrefix + "-" + channel.ident,
      width: channel.spriteImage.width,
      height: channel.spriteImage.height,
      pos: offset - channel.spriteImage.height,
      logoName: "" + filenamePrefix + "-" + channel.ident + ".png",
      logoPath: logoPath
    });
  }
  result = {
    sprite: JSON.stringify(canvas.toDataURL({
      format: "png"
    })),
    css: css,
    width: width,
    height: height,
    moo: moo
  };
  return result;
};

XMLHttpRequest = require('w3c-xmlhttprequest').XMLHttpRequest;

fs = require('fs');

parseXml = require('xml2js').parseString;

http = require('http');

phantom = require("phantom");

done = this.async() || (function() {});

SpriteGenerator = (function() {
  SpriteGenerator.prototype.filenamePrefix = "ritzau-logo";

  SpriteGenerator.prototype.imageDirectory = "ritzau-logos";

  SpriteGenerator.prototype.cssSubDirectory = "ritzau-css";

  SpriteGenerator.prototype.logoPath = "../../img/ritzau-logos/";

  SpriteGenerator.prototype.spriteUrl = "../../img/sprites/ritzau-logos.png";

  SpriteGenerator.prototype.cssTemplate = ".{name} {\n    width: {width}px;\n    height: {height}px;\n    background-image: url(\"{logoPath}{logoName}\");\n}\n.{name}-sprite {\n    width: {width}px;\n    height: {height}px;\n    background-position: 0 -{pos}px;\n}";

  SpriteGenerator.prototype.cssFooterTemplate = "/* Default classes */\n[class*=\"{prefix}\"] {\n    display: block;\n    overflow: hidden;\n    background-repeat: no-repeat;\n    background-image: none;\n    text-indent: -9999px;\n}\n[class*=\"{prefix}\"][class*=-sprite] {\n    background-image: url(\"{spriteUrl}\");\n}";

  /* EPG
  */


  function SpriteGenerator(epgFeedUrl, killer) {
    this.pageResult = __bind(this.pageResult, this);
    this.epgRequestCallback = __bind(this.epgRequestCallback, this);
    var options;
    options = options || {};
    grunt.log.write("Generating Ritzau logos + sprite ...");
    this.epgFeedUrl = epgFeedUrl;
    if (!!options.filenamePrefix) {
      this.filenamePrefix = options.filenamePrefix;
    }
    if (!!options.imageDirectory) {
      this.imageDirectory = options.imageDirectory;
    }
    if (!!options.cssDirectory) {
      this.cssSubDirectory = options.cssDirectory;
    }
    if (!!options.urlLogos) {
      this.logoPath = options.urlLogos;
    }
    if (!!options.urlSprite) {
      this.spriteUrl = options.urlSprite;
    }
    fs.mkdir(this.imageDirectory, function(error) {});
    this.epgRequest();
  }

  /* EPG
  */


  SpriteGenerator.prototype.epgRequest = function() {
    this.client = new XMLHttpRequest();
    this.client.open("GET", this.epgFeedUrl);
    this.client.addEventListener("load", this.epgRequestCallback, false);
    return this.client.send();
  };

  SpriteGenerator.prototype.epgRequestCallback = function() {
    var data,
      _this = this;
    data = this.client.response;
    return parseXml(data, function(error, result) {
      if ((result != null) && result instanceof Object) {
        _this.channels = result["m_lcha:message"].channels.pop().channel;
        return _this.parseChannels();
      }
    });
  };

  /* Channel parsing
  */


  SpriteGenerator.prototype.parseChannels = function() {
    var channel, i, _i, _len, _ref;
    this.downloadedImages = 0;
    this.parsedImages = 0;
    this.totalImages = 0;
    _ref = this.channels;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      channel = _ref[i];
      channel.ident = [].concat(channel.source_url.toString().split("/")).pop().toLowerCase();
      channel.images = [];
      channel.imageUrls = [];
      if (!!channel.logo_16) {
        channel.imageUrls.push(channel.logo_16.toString());
      }
      if (!!channel.logo_32) {
        channel.imageUrls.push(channel.logo_32.toString());
      }
      if (!!channel.logo_50) {
        channel.imageUrls.push(channel.logo_50.toString());
      }
      this.totalImages += channel.imageUrls.length;
    }
    return this.parseImages();
  };

  /* Image parsing
  */


  SpriteGenerator.prototype.parseImages = function() {
    var channel, i, j, url, _i, _len, _ref, _results;
    _ref = this.channels;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      channel = _ref[i];
      if (!(channel.imageUrls && channel.imageUrls.length > 0)) {
        continue;
      }
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = channel.imageUrls;
        _results1 = [];
        for (j = _j = 0, _len1 = _ref1.length; _j < _len1; j = ++_j) {
          url = _ref1[j];
          _results1.push(this.downloadImages(channel, url, j));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  SpriteGenerator.prototype.downloadImages = function(channel, url, i) {
    var filename,
      _this = this;
    filename = "" + this.imageDirectory + "/" + this.filenamePrefix + "-" + channel.ident + "-temp" + i + ".png";
    return http.get(url, function(response) {
      if (!(response.statusCode >= 200 && response.statusCode < 400)) {
        grunt.log.warn("Failed to download sprite (" + url + " @ " + channel.ident + ") -- Status code: " + response.statusCode);
      }
      return response.pipe(fs.createWriteStream(filename)).on("close", function() {
        _this.downloadedImages++;
        channel.images.push({
          filename: "" + __dirname + "/" + filename,
          url: url,
          dimensions: null,
          dimensionSum: 0
        });
        if (_this.downloadedImages === _this.totalImages) {
          return _this.generateSprite();
        }
      });
    });
  };

  SpriteGenerator.prototype.generateSprite = function() {
    var channel, fn, html, image, params, temp, ws, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    html = "<canvas id=\"sprite\"></canvas>";
    _ref = this.channels;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      channel = _ref[_i];
      if (!(channel.imageUrls && channel.imageUrls.length > 0)) {
        continue;
      }
      _ref1 = channel.images;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        image = _ref1[_j];
        html += "<img src=\"" + image.filename + "\" data-ident=\"" + channel.ident + "\" />";
      }
    }
    temp = "" + __dirname + "/temp.html";
    ws = fs.createWriteStream(temp);
    ws.write(html);
    ws.close();
    params = {
      channels: this.channels,
      cssTemplate: this.cssTemplate,
      logoPath: this.logoPath,
      filenamePrefix: this.filenamePrefix
    };
    fn = "function() { return (" + (evaluation.toString()) + ").apply(this, " + (JSON.stringify([params])) + ");}";
    return phantom.create("--local-to-remote-url-access=yes", function(ph) {
      _this.phantom = ph;
      return ph.createPage(function(page) {
        return page.open(temp, function(status) {
          return page.evaluate(fn, _this.pageResult);
        });
      });
    });
  };

  /* Phantom
  */


  SpriteGenerator.prototype.pageResult = function(result) {
    var buffer;
    this.phantom.exit();
    console.log(JSON.stringify(result.moo));
    buffer = result.sprite.substring(1, result.sprite.length - 2);
    buffer = buffer.replace(/^data:image\/png;base64,/, "");
    fs.writeFile("" + __dirname + "/out.png", buffer, 'base64', function(error) {
      if (error) {
        return grunt.log.error("Failed to save sprite");
      } else {
        return grunt.log.ok("Sprite saved");
      }
    });
    fs.writeFile("" + __dirname + "/out.css", result.css, function(error) {
      if (error) {
        return grunt.log.error("Failed to save stylesheet");
      } else {
        return grunt.log.ok("Stylesheet saved");
      }
    });
    return done();
  };

  return SpriteGenerator;

})();

new SpriteGenerator("http://epgpack:7777/susepg/REST/channels", (function() {}));
